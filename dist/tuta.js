/*!
 * Copyright 2017, nju33
 * Released under the MIT License
 * https://github.com/nju33/tuta
 */
var Tuta = (function () {
'use strict';

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var performanceNow = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);
});

var now = performanceNow;
var root = typeof window === 'undefined' ? commonjsGlobal : window;
var vendors = ['moz', 'webkit'];
var suffix = 'AnimationFrame';
var raf = root['request' + suffix];
var caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

var index = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
var cancel = function() {
  caf.apply(root, arguments);
};
var polyfill = function() {
  root.requestAnimationFrame = raf;
  root.cancelAnimationFrame = caf;
};

index.cancel = cancel;
index.polyfill = polyfill;

function appendNode ( node, target ) {
	target.appendChild( node );
}

function insertNode ( node, target, anchor ) {
	target.insertBefore( node, anchor );
}

function detachNode ( node ) {
	node.parentNode.removeChild( node );
}

function detachBetween ( before, after ) {
	while ( before.nextSibling && before.nextSibling !== after ) {
		before.parentNode.removeChild( before.nextSibling );
	}
}

function createElement ( name ) {
	return document.createElement( name );
}

function createSvgElement ( name ) {
	return document.createElementNS( 'http://www.w3.org/2000/svg', name );
}

function createText ( data ) {
	return document.createTextNode( data );
}

function createComment () {
	return document.createComment( '' );
}

function addEventListener ( node, event, handler ) {
	node.addEventListener ( event, handler, false );
}

function removeEventListener ( node, event, handler ) {
	node.removeEventListener ( event, handler, false );
}

function setAttribute ( node, attribute, value ) {
	node.setAttribute ( attribute, value );
}

function get ( key ) {
	return key ? this._state[ key ] : this._state;
}

function fire ( eventName, data ) {
	var handlers = eventName in this._handlers && this._handlers[ eventName ].slice();
	if ( !handlers ) return;

	for ( var i = 0; i < handlers.length; i += 1 ) {
		handlers[i].call( this, data );
	}
}

function observe ( key, callback, options ) {
	var group = ( options && options.defer ) ? this._observers.pre : this._observers.post;

	( group[ key ] || ( group[ key ] = [] ) ).push( callback );

	if ( !options || options.init !== false ) {
		callback.__calling = true;
		callback.call( this, this._state[ key ] );
		callback.__calling = false;
	}

	return {
		cancel: function () {
			var index = group[ key ].indexOf( callback );
			if ( ~index ) group[ key ].splice( index, 1 );
		}
	};
}

function on ( eventName, handler ) {
	var handlers = this._handlers[ eventName ] || ( this._handlers[ eventName ] = [] );
	handlers.push( handler );

	return {
		cancel: function () {
			var index = handlers.indexOf( handler );
			if ( ~index ) handlers.splice( index, 1 );
		}
	};
}

function set ( newState ) {
	this._set( newState );
	( this._root || this )._flush();
}

function _flush () {
	if ( !this._renderHooks ) return;

	while ( this._renderHooks.length ) {
		var hook = this._renderHooks.pop();
		hook.fn.call( hook.context );
	}
}

function noop () {}

function dispatchObservers ( component, group, newState, oldState ) {
	for ( var key in group ) {
		if ( !( key in newState ) ) continue;

		var newValue = newState[ key ];
		var oldValue = oldState[ key ];

		if ( newValue === oldValue && typeof newValue !== 'object' ) continue;

		var callbacks = group[ key ];
		if ( !callbacks ) continue;

		for ( var i = 0; i < callbacks.length; i += 1 ) {
			var callback = callbacks[i];
			if ( callback.__calling ) continue;

			callback.__calling = true;
			callback.call( component, newValue, oldValue );
			callback.__calling = false;
		}
	}
}

var template = (function () {
return {
  data() {
    return {
      defaultStyle: {
        width: '10em',
        height: '2em',
        border: '1px solid #222',
        borderRadius: '2px',
        transition: '.2s cubic-bezier(0.455, 0.03, 0.515, 0.955)',
        baseColor: '#fff',
        subColor: '#222',
        accentColor: '#cb1b45'
      },
      icon: null,
      // icon: '<svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 475.084 475.084" enable-background="new 0 0 475.084 475.084"><path d="M464.5 412.8l-98-98C390.3 281 402 243 402 201c0-27.2-5.3-53.2-16-78-10.4-25-24.7-46.3-42.7-64.3-18-18-39.4-32.3-64.2-43C254.3 5.4 228.3 0 201 0c-27.2 0-53.2 5.3-78 15.8-25 10.6-46.3 25-64.3 43s-32.3 39.3-43 64C5.4 148 0 174 0 201c0 27.2 5.3 53.2 15.8 78 10.6 25 25 46.3 43 64.3s39.3 32.3 64 43c25 10.4 51 15.7 78.2 15.7 42 0 80-11.8 114-35.4l97.8 97.6c7 7.3 15.5 11 25.7 11 10 0 18.5-3.7 25.7-11 7.3-7.2 11-15.8 11-25.7 0-10-3.6-18.6-10.7-25.7zm-173-121.4C266.2 316.4 236 329 201 329s-65.3-12.6-90.4-37.6c-25-25-37.5-55.2-37.5-90.4s12.6-65.3 37.6-90.4c25-25 55.2-37.5 90.4-37.5s65.3 12.6 90.4 37.6c25 25 37.5 55.2 37.5 90.4s-12.6 65.3-37.6 90.4z"/></svg>',
      iconPosition: 'right',
      style: null,

      onSubmit(text, form, reset) {
        console.log('text', text);
        console.log('form', form);
        reset();
      },

      __focus: false,
      __buttonActive: false
    };
  },
  methods: {
    handleFocus() {
      this.set({__focus: true});
    },
    handleBlur() {
      if (!this.refs.input.value) {
        this.set({__focus: false});
      }
    },
    enterButton() {
      this.set({__buttonActive: true});
    },
    leaveButton() {
      this.set({__buttonActive: false});
    },
    handleSubmit(ev) {
      ev.preventDefault();
      if (!this.get('__focus')) {
        this.set({__focus: true});
        this.refs.input.focus();
        return;
      }

      if (!this.refs.input.value) {
        return;
      }

      this.get('onSubmit')(
        this.refs.input.value, this.refs.button.form, this.reset.bind(this)
      );
    },
    reset() {
      this.set({__focus: false});
      this.refs.input.value = '';
    }
  },
  oncreate() {
    if (!/left|right/.test(this.get('iconPosition'))) {
      throw new Error('Specify `left` or `right` for `data.iconPosition`');
    }

    if (this.get('style') === null) {
      this.set({style: Object.assign({}, this.defaultStyle)});
    }

    this.observe('style', newStyle => {
      const {defaultStyle} = this.get();

      if (typeof newStyle === 'undefined') {
        this.set({
          style: defaultStyle
        });
        return;
      }

      if (typeof newStyle !== 'object' ||
          Array.isArray(newStyle)) {
        throw new Error('`style` must be Object');
      }

      this.set({
        style: Object.assign({}, defaultStyle, newStyle)
      });
    });
  }
};
}());

let addedCss = false;
function addCss () {
	var style = createElement( 'style' );
	style.textContent = "\nsvg[svelte-442968154], [svelte-442968154] svg {\n  display: block;\n}\n\n[svelte-442968154].form, [svelte-442968154] .form {\n  position: relative;\n}\n\n[svelte-442968154].input, [svelte-442968154] .input,\n[svelte-442968154].button, [svelte-442968154] .button {\n  position: absolute;\n  bottom: 50%;\n  transform: translateY(50%);\n  font-size: inherit;\n  box-sizing: border-box;\n  padding: .3em .5em;\n  border: none;\n  background: transparent;\n  outline: none;\n}\n\n[svelte-442968154].input, [svelte-442968154] .input {\n  text-align: right;\n  z-index: 1;\n}\n\n[svelte-442968154].button, [svelte-442968154] .button {\n  cursor: pointer;\n  z-index: 2;\n}\n";
	appendNode( style, document.head );

	addedCss = true;
}

function renderMainFragment ( root, component ) {
	var ifBlock_anchor = createComment();
	
	function getBlock ( root ) {
		if ( root.style ) return renderIfBlock_0;
		return null;
	}
	
	var currentBlock = getBlock( root );
	var ifBlock = currentBlock && currentBlock( root, component );

	return {
		mount: function ( target, anchor ) {
			insertNode( ifBlock_anchor, target, anchor );
			if ( ifBlock ) ifBlock.mount( ifBlock_anchor.parentNode, ifBlock_anchor );
		},
		
		update: function ( changed, root ) {
			var __tmp;
		
			var _currentBlock = currentBlock;
			currentBlock = getBlock( root );
			if ( _currentBlock === currentBlock && ifBlock) {
				ifBlock.update( changed, root );
			} else {
				if ( ifBlock ) ifBlock.teardown( true );
				ifBlock = currentBlock && currentBlock( root, component );
				if ( ifBlock ) ifBlock.mount( ifBlock_anchor.parentNode, ifBlock_anchor );
			}
		},
		
		teardown: function ( detach ) {
			if ( ifBlock ) ifBlock.teardown( detach );
			
			if ( detach ) {
				detachNode( ifBlock_anchor );
			}
		}
	};
}

function renderIfBlock_0 ( root, component ) {
	var div = createElement( 'div' );
	setAttribute( div, 'svelte-442968154', '' );
	component.refs.box = div;
	div.className = "tuta form " + ( root.__focus ? 'active' : '' );
	div.style.cssText = "\n    min-width: 2em;\n    height: " + ( root.style.height ) + ";\n  ";
	
	var input = createElement( 'input' );
	setAttribute( input, 'svelte-442968154', '' );
	component.refs.input = input;
	input.type = "text";
	input.className = "tuta input";
	
	function focusHandler ( event ) {
		component.handleFocus();
	}
	
	addEventListener( input, 'focus', focusHandler );
	
	function blurHandler ( event ) {
		component.handleBlur();
	}
	
	addEventListener( input, 'blur', blurHandler );
	
	input.style.cssText = "\n        width: " + ( root.__focus ? root.style.width : '2em' ) + ";\n        height: " + ( root.style.height ) + ";\n        border: " + ( root.__focus ? root.style.border : '1px solid transparent' ) + ";\n        border-radius: " + ( root.style.borderRadius ) + ";\n        -webkit-transition: " + ( root.style.transition ) + ";\n        transition: " + ( root.style.transition ) + ";\n        color: " + ( root.__focus ? 'inherit' : 'transparent' ) + ";\n        font-size: calc(" + ( root.style.height ) + " / 1.618);\n        background: " + ( root.__focus ? root.style.baseColor : '' ) + ";\n\n        " + ( root.iconPosition === 'left' ? 'left: -1.1em' : 'right: .4em' ) + ";\n        " + ( root.iconPosition === 'left' ? 'text-align: left' : 'text-align: right' ) + ";\n        " + ( root.iconPosition === 'left' ? 'padding-left: 2em' : 'padding-right: 2em' ) + ";\n      ";
	
	appendNode( input, div );
	appendNode( createText( "\n    " ), div );
	
	var button = createElement( 'button' );
	setAttribute( button, 'svelte-442968154', '' );
	component.refs.button = button;
	button.className = "tuta button";
	button.style.cssText = "\n      width: 2em;\n      height: calc(" + ( root.style.height ) + " / 1.618);\n      -webkit-transition: " + ( root.style.transition ) + ";\n      transition: color " + ( root.style.transition ) + ", fill " + ( root.style.transition ) + ";\n      color: " + ( root.__buttonActive ? root.style.accentColor : 'inherit' ) + ";\n      fill: " + ( root.__buttonActive ? root.style.accentColor : 'inherit' ) + ";\n      " + ( root.iconPosition === 'left' ? 'left: -1em' : 'right: 1em' ) + ";\n    ";
	
	function mouseoverHandler ( event ) {
		component.enterButton();
	}
	
	addEventListener( button, 'mouseover', mouseoverHandler );
	
	function mouseleaveHandler ( event ) {
		component.leaveButton();
	}
	
	addEventListener( button, 'mouseleave', mouseleaveHandler );
	
	function clickHandler ( event ) {
		component.handleSubmit(event);
	}
	
	addEventListener( button, 'click', clickHandler );
	
	appendNode( button, div );
	var ifBlock1_anchor = createComment();
	appendNode( ifBlock1_anchor, button );
	
	function getBlock1 ( root ) {
		if ( root.icon !== null ) return renderIfBlock1_0;
		return renderIfBlock1_1;
	}
	
	var currentBlock1 = getBlock1( root );
	var ifBlock1 = currentBlock1 && currentBlock1( root, component );
	
	if ( ifBlock1 ) ifBlock1.mount( ifBlock1_anchor.parentNode, ifBlock1_anchor );

	return {
		mount: function ( target, anchor ) {
			insertNode( div, target, anchor );
		},
		
		update: function ( changed, root ) {
			var __tmp;
		
			div.className = "tuta form " + ( root.__focus ? 'active' : '' );
			div.style.cssText = "\n    min-width: 2em;\n    height: " + ( root.style.height ) + ";\n  ";
			
			input.style.cssText = "\n        width: " + ( root.__focus ? root.style.width : '2em' ) + ";\n        height: " + ( root.style.height ) + ";\n        border: " + ( root.__focus ? root.style.border : '1px solid transparent' ) + ";\n        border-radius: " + ( root.style.borderRadius ) + ";\n        -webkit-transition: " + ( root.style.transition ) + ";\n        transition: " + ( root.style.transition ) + ";\n        color: " + ( root.__focus ? 'inherit' : 'transparent' ) + ";\n        font-size: calc(" + ( root.style.height ) + " / 1.618);\n        background: " + ( root.__focus ? root.style.baseColor : '' ) + ";\n\n        " + ( root.iconPosition === 'left' ? 'left: -1.1em' : 'right: .4em' ) + ";\n        " + ( root.iconPosition === 'left' ? 'text-align: left' : 'text-align: right' ) + ";\n        " + ( root.iconPosition === 'left' ? 'padding-left: 2em' : 'padding-right: 2em' ) + ";\n      ";
			
			button.style.cssText = "\n      width: 2em;\n      height: calc(" + ( root.style.height ) + " / 1.618);\n      -webkit-transition: " + ( root.style.transition ) + ";\n      transition: color " + ( root.style.transition ) + ", fill " + ( root.style.transition ) + ";\n      color: " + ( root.__buttonActive ? root.style.accentColor : 'inherit' ) + ";\n      fill: " + ( root.__buttonActive ? root.style.accentColor : 'inherit' ) + ";\n      " + ( root.iconPosition === 'left' ? 'left: -1em' : 'right: 1em' ) + ";\n    ";
			
			var _currentBlock1 = currentBlock1;
			currentBlock1 = getBlock1( root );
			if ( _currentBlock1 === currentBlock1 && ifBlock1) {
				ifBlock1.update( changed, root );
			} else {
				if ( ifBlock1 ) ifBlock1.teardown( true );
				ifBlock1 = currentBlock1 && currentBlock1( root, component );
				if ( ifBlock1 ) ifBlock1.mount( ifBlock1_anchor.parentNode, ifBlock1_anchor );
			}
		},
		
		teardown: function ( detach ) {
			if ( component.refs.box === div ) component.refs.box = null;
			if ( component.refs.input === input ) component.refs.input = null;
			removeEventListener( input, 'focus', focusHandler );
			removeEventListener( input, 'blur', blurHandler );
			if ( component.refs.button === button ) component.refs.button = null;
			removeEventListener( button, 'mouseover', mouseoverHandler );
			removeEventListener( button, 'mouseleave', mouseleaveHandler );
			removeEventListener( button, 'click', clickHandler );
			if ( ifBlock1 ) ifBlock1.teardown( false );
			
			if ( detach ) {
				detachNode( div );
			}
		}
	};
}

function renderIfBlock1_1 ( root, component ) {
	var svg = createSvgElement( 'svg' );
	setAttribute( svg, 'svelte-442968154', '' );
	setAttribute( svg, 'version', "1.1" );
	setAttribute( svg, 'viewBox', "0 0 16 16" );
	setAttribute( svg, 'class', "octicon octicon-search" );
	setAttribute( svg, 'aria-hidden', "true" );
	
	var path = createSvgElement( 'path' );
	setAttribute( path, 'svelte-442968154', '' );
	setAttribute( path, 'fill-rule', "evenodd" );
	setAttribute( path, 'd', "M15.7 13.3l-3.81-3.83A5.93 5.93 0 0 0 13 6c0-3.31-2.69-6-6-6S1 2.69 1 6s2.69 6 6 6c1.3 0 2.48-.41 3.47-1.11l3.83 3.81c.19.2.45.3.7.3.25 0 .52-.09.7-.3a.996.996 0 0 0 0-1.41v.01zM7 10.7c-2.59 0-4.7-2.11-4.7-4.7 0-2.59 2.11-4.7 4.7-4.7 2.59 0 4.7 2.11 4.7 4.7 0 2.59-2.11 4.7-4.7 4.7z" );
	
	appendNode( path, svg );

	return {
		mount: function ( target, anchor ) {
			insertNode( svg, target, anchor );
		},
		
		update: noop,
		
		teardown: function ( detach ) {
			if ( detach ) {
				detachNode( svg );
			}
		}
	};
}

function renderIfBlock1_0 ( root, component ) {
	var raw_before = createElement( 'noscript' );
	var raw_after = createElement( 'noscript' );
	var last_raw = root.icon;

	return {
		mount: function ( target, anchor ) {
			insertNode( raw_before, target, anchor );
			insertNode( raw_after, target, anchor );
			raw_before.insertAdjacentHTML( 'afterend', last_raw );
		},
		
		update: function ( changed, root ) {
			var __tmp;
		
			if ( ( __tmp = root.icon ) !== last_raw ) {
				last_raw = __tmp;
				detachBetween( raw_before, raw_after );
				raw_before.insertAdjacentHTML( 'afterend', last_raw );
			}
		},
		
		teardown: function ( detach ) {
			if ( detach ) {
				detachBetween( raw_before, raw_after );
				
				detachNode( raw_before );
				detachNode( raw_after );
			}
		}
	};
}

function Tuta$1 ( options ) {
	options = options || {};
	this.refs = {};
	this._state = Object.assign( template.data(), options.data );
	
	this._observers = {
		pre: Object.create( null ),
		post: Object.create( null )
	};
	
	this._handlers = Object.create( null );
	
	this._root = options._root;
	this._yield = options._yield;
	
	this._torndown = false;
	if ( !addedCss ) addCss();
	
	this._fragment = renderMainFragment( this._state, this );
	if ( options.target ) this._fragment.mount( options.target, null );
	
	if ( options._root ) {
		options._root._renderHooks.push({ fn: template.oncreate, context: this });
	} else {
		template.oncreate.call( this );
	}
}

Tuta$1.prototype = template.methods;

Tuta$1.prototype.get = get;
Tuta$1.prototype.fire = fire;
Tuta$1.prototype.observe = observe;
Tuta$1.prototype.on = on;
Tuta$1.prototype.set = set;
Tuta$1.prototype._flush = _flush;

Tuta$1.prototype._set = function _set ( newState ) {
	var oldState = this._state;
	this._state = Object.assign( {}, oldState, newState );
	
	dispatchObservers( this, this._observers.pre, newState, oldState );
	if ( this._fragment ) this._fragment.update( newState, this._state );
	dispatchObservers( this, this._observers.post, newState, oldState );
};

Tuta$1.prototype.teardown = Tuta$1.prototype.destroy = function destroy ( detach ) {
	this.fire( 'teardown' );

	this._fragment.teardown( detach !== false );
	this._fragment = null;

	this._state = {};
	this._torndown = true;
};

return Tuta$1;

}());
